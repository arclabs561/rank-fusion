//! Property tests for rank-fusion algorithms.
//!
//! These tests verify invariants that should always hold:
//! - Output is sorted descending
//! - No duplicate IDs
//! - Commutativity (order of input lists doesn't matter)
//! - Bounds (output size, score ranges)
//! - Edge cases (empty lists, NaN, Infinity)

#[cfg(test)]
mod tests {
    use super::super::*;
    use proptest::prelude::*;
    use std::collections::HashMap;

    fn arb_results(max_len: usize) -> impl Strategy<Value = Vec<(u32, f32)>> {
        proptest::collection::vec((0u32..100, 0.0f32..1.0), 0..max_len)
    }

    proptest! {
        #[test]
        fn rrf_output_bounded(a in arb_results(50), b in arb_results(50)) {
            let result = rrf(&a, &b);
            prop_assert!(result.len() <= a.len() + b.len());
        }

        #[test]
        fn rrf_scores_positive(a in arb_results(50), b in arb_results(50)) {
            let result = rrf(&a, &b);
            for (_, score) in &result {
                prop_assert!(*score > 0.0);
            }
        }

        #[test]
        fn rrf_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = rrf(&a, &b);
            let ba = rrf(&b, &a);

            prop_assert_eq!(ab.len(), ba.len());

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();

            for (id, score_ab) in &ab_map {
                let score_ba = ba_map.get(id).expect("same keys");
                prop_assert!((score_ab - score_ba).abs() < 1e-6);
            }
        }

        #[test]
        fn rrf_sorted_descending(a in arb_results(50), b in arb_results(50)) {
            let result = rrf(&a, &b);
            for window in result.windows(2) {
                prop_assert!(window[0].1 >= window[1].1);
            }
        }

        #[test]
        fn rrf_top_k_respected(a in arb_results(50), b in arb_results(50), k in 1usize..20) {
            let result = rrf_with_config(&a, &b, RrfConfig::default().with_top_k(k));
            prop_assert!(result.len() <= k);
        }

        #[test]
        fn borda_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = borda(&a, &b);
            let ba = borda(&b, &a);

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();
            prop_assert_eq!(ab_map, ba_map);
        }

        #[test]
        fn combsum_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = combsum(&a, &b);
            let ba = combsum(&b, &a);

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();

            prop_assert_eq!(ab_map.len(), ba_map.len());
            for (id, score_ab) in &ab_map {
                let score_ba = ba_map.get(id).unwrap();
                prop_assert!((score_ab - score_ba).abs() < 1e-5);
            }
        }

        #[test]
        fn combmnz_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = combmnz(&a, &b);
            let ba = combmnz(&b, &a);

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();

            prop_assert_eq!(ab_map.len(), ba_map.len());
            for (id, score_ab) in &ab_map {
                let score_ba = ba_map.get(id).expect("same keys");
                prop_assert!((score_ab - score_ba).abs() < 1e-5,
                    "CombMNZ not commutative for id {:?}: {} vs {}", id, score_ab, score_ba);
            }
        }

        #[test]
        fn dbsf_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = dbsf(&a, &b);
            let ba = dbsf(&b, &a);

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();

            prop_assert_eq!(ab_map.len(), ba_map.len());
            for (id, score_ab) in &ab_map {
                let score_ba = ba_map.get(id).expect("same keys");
                prop_assert!((score_ab - score_ba).abs() < 1e-5,
                    "DBSF not commutative for id {:?}: {} vs {}", id, score_ab, score_ba);
            }
        }

        #[test]
        fn isr_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = isr(&a, &b);
            let ba = isr(&b, &a);

            prop_assert_eq!(ab.len(), ba.len());

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();

            for (id, score_ab) in &ab_map {
                let score_ba = ba_map.get(id).expect("same keys");
                prop_assert!((score_ab - score_ba).abs() < 1e-6);
            }
        }

        #[test]
        fn isr_sorted_descending(a in arb_results(50), b in arb_results(50)) {
            let result = isr(&a, &b);
            for window in result.windows(2) {
                prop_assert!(window[0].1 >= window[1].1);
            }
        }

        #[test]
        fn all_methods_sorted_descending(a in arb_results(20), b in arb_results(20)) {
            for result in [
                rrf(&a, &b),
                combsum(&a, &b),
                combmnz(&a, &b),
                borda(&a, &b),
                isr(&a, &b),
                dbsf(&a, &b),
            ] {
                for window in result.windows(2) {
                    prop_assert!(
                        window[0].1.total_cmp(&window[1].1) != std::cmp::Ordering::Less,
                        "Not sorted: {} < {}", window[0].1, window[1].1
                    );
                }
            }
        }

        #[test]
        fn all_methods_have_unique_ids(a in arb_results(20), b in arb_results(20)) {
            for result in [
                rrf(&a, &b),
                combsum(&a, &b),
                combmnz(&a, &b),
                borda(&a, &b),
                isr(&a, &b),
                dbsf(&a, &b),
            ] {
                let mut seen = std::collections::HashSet::new();
                for (id, _) in &result {
                    prop_assert!(seen.insert(id), "Duplicate ID in output: {:?}", id);
                }
            }
        }

        #[test]
        fn standardized_commutative(a in arb_results(20), b in arb_results(20)) {
            let ab = standardized(&a, &b);
            let ba = standardized(&b, &a);

            let ab_map: HashMap<_, _> = ab.into_iter().collect();
            let ba_map: HashMap<_, _> = ba.into_iter().collect();

            prop_assert_eq!(ab_map.len(), ba_map.len());
            for (id, score_ab) in &ab_map {
                let score_ba = ba_map.get(id).expect("same keys");
                prop_assert!((score_ab - score_ba).abs() < 1e-5,
                    "Standardized not commutative for id {:?}: {} vs {}", id, score_ab, score_ba);
            }
        }

        #[test]
        fn additive_multi_task_sorted_descending(a in arb_results(20), b in arb_results(20)) {
            let config = AdditiveMultiTaskConfig::default();
            let result = additive_multi_task_with_config(&a, &b, config);
            for window in result.windows(2) {
                prop_assert!(window[0].1 >= window[1].1);
            }
        }
    }
}

